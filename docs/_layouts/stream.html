---
layout: default
---

<canvas id="testcanvas"></canvas>

<script type="text/javascript">
    function base64ArrayBuffer(arrayBuffer) {
        let base64    = '';
        let encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

        let bytes         = new Uint8Array(arrayBuffer);
        let byteLength    = bytes.byteLength;
        let byteRemainder = byteLength % 3;
        let mainLength    = byteLength - byteRemainder;

        let a, b, c, d;
        let chunk;

        // Main loop deals with bytes in chunks of 3
        for (let i = 0; i < mainLength; i = i + 3) {
            // Combine the three bytes into a single integer
            chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

            // Use bitmasks to extract 6-bit segments from the triplet
            a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
            b = (chunk & 258048)   >> 12; // 258048   = (2^6 - 1) << 12
            c = (chunk & 4032)     >>  6; // 4032     = (2^6 - 1) << 6
            d = chunk & 63 ;              // 63       = 2^6 - 1

            // Convert the raw binary segments to the appropriate ASCII encoding
            base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
        }

        // Deal with the remaining bytes and padding
        if (byteRemainder === 1) {
            chunk = bytes[mainLength];

            a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2

            // Set the 4 least significant bits to zero
            b = (chunk & 3)   << 4; // 3   = 2^2 - 1

            base64 += encodings[a] + encodings[b] + '=='
        } else if (byteRemainder === 2) {
            chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];

            a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
            b = (chunk & 1008)  >>  4; // 1008  = (2^6 - 1) << 4

            // Set the 2 least significant bits to zero
            c = (chunk & 15)    <<  2; // 15    = 2^4 - 1

            base64 += encodings[a] + encodings[b] + encodings[c] + '=';
        }

        return base64;
    }

    let canvas = document.getElementById("testcanvas");
    canvas.width = 960;
    canvas.height = 540;
    let context = canvas.getContext('2d');
    let img = new Image();
    img.onload = function() {
        context.drawImage(img, 0, 0);
    };
    let lastTime = 0;
    let ws = new WebSocket('wss://api.chilly.codes/switch/stream');
    ws.binaryType = 'arraybuffer';

    let byteSize = 0;
    let frameCount = 0;
    let lastBitrateUpdate = new Date().getTime();

    ws.addEventListener('message', function(e) {
        // What goes in the response:
        // 1 byte: image format
        // 1 byte: image quality
        // 8 byte: encoding timestamp (ms)
        // ?? bytes: frame
        let data = e.data;
        byteSize += data.byteLength;
        frameCount++;
        let dv = new DataView(data);
        let formatString = 'unknown';
        let format = dv.getInt8(0);
        let quality = dv.getInt8(1);

        if (format === 3) {
            formatString = 'jpeg';
        } else if (format === 6) {
            formatString = 'webp';
        }

        // Stupid JavaScript not having support for real 64 bit integers
        let ts = dv.getFloat64(2);
        let encodingTimeToDisplay = new Date().getTime() - ts;
        img.src = 'data:image;base64,' + base64ArrayBuffer(data.slice(10));
    });

    function draw() {
        let time = new Date().getTime();
        if (ws.readyState === ws.OPEN && lastTime + 30 < time) {
            ws.send('request');
            lastTime = time;
        }
        if (time - lastBitrateUpdate >= 1000) {
            let secs = ((time - lastBitrateUpdate)/1000.0);
            console.log(`Bitrate: ${byteSize / 128.0 / secs} kbps (${frameCount / secs} fps)`);
            lastBitrateUpdate = time;
            byteSize = 0;
            frameCount = 0;
        }
        requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);

    window.sendWsMessage = function(val) {
        ws.send(val);
    }

</script>